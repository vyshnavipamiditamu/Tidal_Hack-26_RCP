def get_matching_pairs(df1, df2):
    # 1. Ensure we are looking for ANY metal loss
    # (Matches 'Internal Metal Loss', 'External', etc.)
    df1_ml = df1[df1['feature_type'].str.contains('Metal Loss|Loss', na=False, case=False)]
    df2_ml = df2[df2['feature_type'].str.contains('Metal Loss|Loss', na=False, case=False)]
    
    if len(df1_ml) == 0 or len(df2_ml) == 0:
        print("❌ One of the years has no 'Metal Loss' events labeled. Check feature_type names!")
        return pd.DataFrame()

    # 2. Create the Cost Matrix
    # We use a 20-foot tolerance because matching rust is harder than matching welds
    dist_matrix = np.abs(df1_ml['aligned_dist'].values[:, np.newaxis] - df2_ml['distance'].values)
    
    # 3. Hungarian Algorithm
    row_ind, col_ind = linear_sum_assignment(dist_matrix)
    
    matches = []
    for r, c in zip(row_ind, col_ind):
        # Increased tolerance to 20 feet to find those 'hidden' matches
        if dist_matrix[r, c] < 20.0: 
            matches.append({
                'id_2015': r,
                'location_22': df2_ml.iloc[c]['distance'],
                'dist_diff': dist_matrix[r, c],
                'depth_15': df1_ml.iloc[r]['depth'],
                'depth_22': df2_ml.iloc[c]['depth']
            })
    return pd.DataFrame(matches)

# Execute again
matched_df = get_matching_pairs(df_15_final, df_22)
print(f"✅ Pairing attempt finished. Found {len(matched_df)} matches!")
